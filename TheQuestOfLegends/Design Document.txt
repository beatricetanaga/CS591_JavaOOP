DESIGN DOCUMENT for The Quest of Legends Assignment

Team #8 
Names of Team Members: 
Priya Kumari (BU ID: U21518661)
Beatrice Tanaga (BU ID: U90936184)

**We have chosen to build entirely from Priya's Quest assignment for a couple of reasons. First of all, after examining both of our code, we felt that Priya's code better followed OOP principles. It contained classes, rather than enums, for all of the major and minor components of the game. It utilized reasonable inheritance, abstraction, and composition relationships between all of the classes and interfaces. Second, its clear structure, along with the fact that none of the code was hard-coded, made the code more easily reusable and extendable to the Quest of Legends assignment. Lastly, since the code was written clearly and included comments for every method, it was readable and could be understood easily. This meant that we could understand all of the existing functionality well enough to know what parts we already had code for and allowed us to build new methods and classes from the existing code.** 





Information on the Design of Each Class: 

PlayGameMain: This class is exactly the same as Priya's previous implementation. 

GameDriver: This class is the same as Priya's previous implementation except that the executeGame method has been altered to match the flow of The Quest of Legends game and some new methods have been added. Since this game has monsters participate in the game as heroes do, a createMonsters method, similar to the previous createHeroes method, has been added. The max and min number of heroes to be played with have both been set to 3. In addition, a findFighters method, which finds all the monsters and heroes in the neighboring cells of a hero and initiates a fight, along with its helper methods, have been added to this class. The reason we have added these new methods to this class is because creating monsters and finding creatures to fight are critical to the execution and flow of the game. 

HeroCreationHelper: This class is the same as Priya's previous implementation except the strengths of the heroes have been reduced to lower numbers to make the game more fair as it was becoming too easy for the heroes to win now with their stats being boosted every round they remained in the same tile.  

Fightable: This is a completely new interface. The reason we added this interface is to follow Object Oriented Design principles and enforce fighting behaviors for both heroes and monsters. 

LivingCreature: This is a completely new class. The reason we added this class is to follow Object Oriented Design principles and have a level of inheritance that shows that heroes and monsters are both living creatures that can make moves, win the game, die in a fight, etc. This class implements the Fightable interface since we wanted to show that all living creatures in this game have fighting behaviors and must therefore implement fight-related methods.   

Team: This is a completely new class. The reason we added this class is to represent the fact that all the heroes and all of the monsters each belong to a team and that if a single creature reaches the opponent's nexus, it is a win for their entire team.  

Hero: This class is the same as Priya's previous implementation with a few a changes. First, the class extends LivingCreature now and some attributes that are common to monsters and heroes have been moved from the Hero class to the LivingCreature class to reflect the fact that they are not specific to only heroes and better follow the inheritance structure of OOP. Second, some methods like makeMove, backMove, respawn, teleportTo, and hasWon have been added to the class. The reason we added these methods is to provide the functionality that is new to heroes in this game, including being able to each make their own moves on the map, teleport, respawn, return to their nexus, and earn a win for their team. 

Skill: This class is exactly the same as Priya's previous implementation. 

Paladin: This class is exactly the same as Priya's previous implementation.

Sorcerer: This class is exactly the same as Priya's previous implementation. 

Warrior: This class is exactly the same as Priya's previous implementation.

QuestMap: This class has several changes from Priya's previous implementation. Since the new map includes lanes, a Lane class was created to follow Object Oriented Design. As a result, this class now has 3 Lane objects as attributes (representing the top, mid, and bot lanes), a method to create lanes, and a constructor that initializes the lanes. Since the new map includes new types of tiles, the createGrid method has been changed to set the tiles of the lanes randomly between these new types of tiles based on certain allocation percentages (55% plain, 15% bush, 15% cave, and 15% koulou). Since the map looks different now, the printQuestMap has been altered as well to display the borders of the tiles. 

Lane: This is a completely new class. We decided to create this class because lanes can be thought of as a component of the map (maps are made up of 3 lanes), and we wanted our design to reflect this important new detail. 

Tile: This class has some changes from Priya's previous implementation. Since tiles can be occupied by 2 creatures now rather than 1, we have added 2 new String attributes called heroLabel and monsterLabel. Since each type of tile has a different border, we have created a printTile method in this class that will print a tile with its proper border. We have also written enter and exit methods for both monsters and heroes since both of these creatures can now enter and exit the tiles. This method is called using the super constructor within the enter and exit methods of its subclasses, which each have additional functionality. The reason we created these methods is to follow the inheritance structure and reflect that there are some common aspects when any type of tile is entered or exited. 

BlockedTile: This class has some changes from Priya's previous implementation. Its label has been changed to X's rather than straight lines to look more like the provided map and its borderLabel has been set to to "I". Also, its enter and exit methods have been removed since it inherits these methods from its superclass Tile, which will never be called on BlockedTile anyways since these tiles are inaccessible to the creatures. 

BushTile: This is a completely new class. We decided to create this class because bush tiles can be thought of as a component of the map (some of the tiles of the map are bush tiles), and we wanted our design to reflect this important new detail. The result of a hero entering this type of tile is unique, so we wanted a separate class to reflect this fact.  

CaveTile: This is a completely new class. We decided to create this class because cave tiles can be thought of as a component of the map (some of the tiles of the map are cave tiles), and we wanted our design to reflect this important new detail. The result of a hero entering this type of tile is unique, so we wanted a separate class to reflect this fact.  

KoulouTile: This is a completely new class. We decided to create this class because koulou tiles can be thought of as a component of the map (some of the tiles of the map are koulou tiles), and we wanted our design to reflect this important new detail. The result of a hero entering this type of tile is unique, so we wanted a separate class to reflect this fact.   

PlainTile: This is a completely new class. We decided to create this class because plain tiles can be thought of as a component of the map (some of the tiles of the map are plain tiles), and we wanted our design to reflect this important new detail.  

NexusTile: This is a completely new class. We decided to create this class because nexus tiles can be thought of as a component of the map (the top and bottom rows of the map are nexus tiles), and we wanted our design to reflect this important new detail. 

HeroNexusTile: This is a completely new class. We decided to create this class because hero nexus tiles can be thought of as a component of the map (the bottom row of the map is hero nexus tiles), and we wanted our design to reflect this important new detail. The result of a hero or monster entering this type of nexus tile is different than entering a monster nexus tile, so we wanted a separate class to reflect this fact. 

MonsterNexusTile: This is a completely new class. We decided to create this class because monster nexus tiles can be thought of as a component of the map (the top row of the map is monster nexus tiles), and we wanted our design to reflect this important new detail. The result of a hero or monster entering this type of nexus tile is different than entering a hero nexus tile, so we wanted a separate class to reflect this fact. 

Market: This class is exactly the same as Priya's previous implementation.

ItemConstants: This class is exactly the same as Priya's previous implementation.

Sellable: This is a completely new interface. We decided to add this interface to follow Object Oriented design principles and have a level of abstraction that reflects the ability of items to be bought and sold. 

Item: This class is the same as Priya's previous implementation except that it now implements the Sellable interface and thus implements getPrice and setPrice methods as listed in the interface to reflect an item's ability to be bought and sold.  

Armor: This class is exactly the same as Priya's previous implementation.

Potion: This class is exactly the same as Priya's previous implementation.

Spell: This class is exactly the same as Priya's previous implementation.

IceSpell: This class is exactly the same as Priya's previous implementation.

FireSpell: This class is exactly the same as Priya's previous implementation.

LightningSpell: This class is exactly the same as Priya's previous implementation.

Weapon: This class is exactly the same as Priya's previous implementation.

Fight: This class has some changes from Priya's previous implementation. First, since the Player class has been removed from this implementation, its player attribute has been removed as well. Second, its start method has been changed in 3 ways: 1) temporary monsters are not created at the beginning of the fight since monsters exist in the game outside of the fight, and these are the monsters that participate in the fight; 2) the heroes "re-enter" their current tiles during the fight so that their stats get boosted every round of the fight that they are still in that tile; and 3) when the heroes faint, rather than the game ending, the heros respawn to their nexus so that the game continues. We implemented these changes to better follow the new game's logic and additional rules regarding the heroes' stats. 

MonsterCreationHelper: This class is exactly the same as Priya's previous implementation.

Monster: This class is the same as Priya's previous implementation with a few changes. First, the class extends LivingCreature now and some attributes that are common to monsters and heroes have been moved from the Monster class to the LivingCreature class to reflect the fact that they are not specific to only monsters and better follow the inheritance structure of OOP. Second, some methods like makeMove and hasWon have been added to the class. The reason we added these methods is to provide the functionality that is new to monsters in this game, including being able to move on the map and earn a win for their team by entering the heroes' nexus. 

Dragon: This class is exactly the same as Priya's previous implementation. 

Exoskeleton: This class is exactly the same as Priya's previous implementation.

Spirit: This class is exactly the same as Priya's previous implementation.

UtilityHelper: This class is exactly the same as Priya's previous implementation.






















